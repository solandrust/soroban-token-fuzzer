#![no_main]

use libfuzzer_sys::{fuzz_target, Corpus};
use soroban_sdk::{Address, Env, Error, InvokeError, String, TryFromVal, Val, unwrap::UnwrapOptimized};
use soroban_token_fuzzer::*;
use soroban_sdk::testutils::Address as _;
use soroban_sdk::token;

use comet::c_pool::comet::{CometPoolContract, CometPoolContractClient};

use soroban_sdk::testutils::arbitrary::fuzz_catch_panic;
use soroban_sdk::xdr::{ScErrorType, ScErrorCode};

// This is the entrypoint.
//
// `Input` is randomly generated by the fuzzer and interpreted
// by the `fuzz_token` function.
//
// The `Corpus` return type is used by the fuzzer to communicate
// the results of fuzzing back to the fuzzer, particulary to
// instruct the fuzzer that the `Input` case was unusable
// (for various reasons).
fuzz_target!(|input: Input| -> Corpus {
    // Each token needs to construct its own `Config` by passing
    // to `contract` a type that implements `ContractTokenOps`.
    let config = Config::contract(TokenOps);
    // Run the fuzzer.
    fuzz_token(config, input)
});

// Implements `ContractTokenOps`
struct TokenOps;

// Implements `TokenAdminClient`
struct AdminClient<'a> {
    client: CometPoolContractClient<'a>,
}

impl ContractTokenOps for TokenOps {
    /// Register the contract with the environment and perform
    /// contract-specific one-time initialization.
    ///
    /// This function will be called once.
    fn register_contract_init(&self, env: &Env, admin: &Address) -> Address {
        let token_contract_id = env.register_contract(None, CometPoolContract);

        let admin_client = CometPoolContractClient::new(env, &token_contract_id);

        let factory_address = admin.clone();
        let controller_address = admin.clone();
        
        let r = admin_client.try_init(
            &factory_address,
            &controller_address,
        );
        assert!(r.is_ok());

        // bind tokens
        let token_client_1 = create_and_init_token_contract(env, admin, "TOKENONE", "TOKENONE");
        let token_client_2 = create_and_init_token_contract(env, admin, "TOKENTWO", "TOKENTWO");

        env.mock_all_auths();
        token_client_1.mint(admin, &to_stroop(50_000));
        token_client_2.mint(admin, &to_stroop(50_000));

        // todo: const numbers
        admin_client.bind(&token_client_1.address, &to_stroop(50_000), &to_stroop(12), admin);
        admin_client.bind(&token_client_2.address, &to_stroop(50_000), &to_stroop(12), admin);

        let controller = admin.clone();
        admin_client.set_swap_fee(&3_000, &controller);
        admin_client.finalize();

        token_contract_id
    }

    /// Register the contract with the environment.
    ///
    /// This will be called on all subsequent transactions
    /// after the first, i.e. every time time is advanced
    /// and the `Env` is recreated.
    fn reregister_contract(&self, env: &Env, token_contract_id: &Address) {
        env.register_contract(Some(token_contract_id), CometPoolContract);

        let admin_client = AdminClient {
            client: CometPoolContractClient::new(&env, &token_contract_id),
        };

        let (addr1, addr2) = admin_client.get_token_addresses();

        env.register_contract(Some(&addr1), example_token::contract::Token);
        env.register_contract(Some(&addr2), example_token::contract::Token);
    }

    /// Create an admin client.
    fn new_admin_client<'a>(
        &self,
        env: &Env,
        token_contract_id: &Address,
    ) -> Box<dyn TokenAdminClient<'a> + 'a> {
        Box::new(AdminClient {
            client: CometPoolContractClient::new(&env, &token_contract_id),
        })
    }

    fn keep_contracts_alive(&self, env: &Env, token_contract_id: &Address) {
        let token_client = token::Client::new(&env, &token_contract_id);
        token_client.allowance(&Address::generate(&env), &Address::generate(&env));

        let admin_client = AdminClient {
            client: CometPoolContractClient::new(&env, &token_contract_id),
        };

        let (addr1, addr2) = admin_client.get_token_addresses();

        let token_1_client = token::Client::new(&env, &addr1);
        token_1_client.allowance(&Address::generate(&env), &Address::generate(&env));
        let token_2_client = token::Client::new(&env, &addr2);
        token_2_client.allowance(&Address::generate(&env), &Address::generate(&env));
    }
}

impl<'a> AdminClient<'a> {
    fn get_token_addresses(&self) -> (Address, Address) {
        let pool_tokens = self.client.get_tokens();
        assert_eq!(pool_tokens.len(), 2);

        let token_address_1 = pool_tokens.get(0).unwrap_optimized();
        let token_address_2 = pool_tokens.get(1).unwrap_optimized();

        (token_address_1, token_address_2)
    }
}

impl<'a> TokenAdminClient<'a> for AdminClient<'a> {
    fn try_mint(
        &self,
        to: &Address,
        amount: &i128,
    ) -> Result<Result<(), <() as TryFromVal<Env, Val>>::Error>, Result<Error, InvokeError>> {
        self.client.env.mock_all_auths();

        let (token_address_1, token_address_2) = self.get_token_addresses();
        
        let token_client_1 = example_token::TokenClient::new(&self.client.env, &token_address_1);
        let token_client_2 = example_token::TokenClient::new(&self.client.env, &token_address_2);

        let balance_1 = token_client_1.balance(to);
        let balance_2 = token_client_2.balance(to);

        token_client_1.mint(to, &(i128::MAX - balance_1));
        token_client_2.mint(to, &(i128::MAX - balance_2));
        
        let max_amounts_in = soroban_sdk::vec![&self.client.env, i128::MAX, i128::MAX];

        let r = fuzz_catch_panic(|| self.client.join_pool(amount, &max_amounts_in, to));
        if r.is_err() {
            Err(Err(
                Error::from_type_and_code(ScErrorType::Value, ScErrorCode::InvalidInput).into()
            ))
        } else {
            Ok(Ok(()))
        }
    }
}

fn create_and_init_token_contract<'a>(
    env: &'a Env,
    admin: &'a Address,
    name: &'a str,
    symbol: &'a str,
) -> example_token::TokenClient<'a> {
    let token_contract_id = env.register_contract(None, example_token::contract::Token);

    let client = example_token::TokenClient::new(&env, &token_contract_id);

    client.initialize(
        admin,
        &7,
        &String::from_str(&env, name),
        &String::from_str(&env, symbol),
    );

    client
}

fn to_stroop<T: Into<f64>>(a: T) -> i128 {
    (a.into() * 1e7) as i128
}
