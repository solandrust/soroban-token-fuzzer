#![no_main]

use libfuzzer_sys::{fuzz_target, Corpus};
use soroban_sdk::{Address, Env, Error, InvokeError, String, TryFromVal, Val, unwrap::UnwrapOptimized, ConversionError, xdr::Error as XdrError};
use soroban_token_fuzzer::*;
use example_token;

use comet::c_pool::comet::{CometPoolContract, CometPoolContractClient};
use comet::c_consts::{MAX_CPOW_BASE, MIN_CPOW_BASE, BONE};
use soroban_fixed_point_math::FixedPoint;

use std::panic::{self, AssertUnwindSafe};

// This is the entrypoint.
//
// `Input` is randomly generated by the fuzzer and interpreted
// by the `fuzz_token` function.
//
// The `Corpus` return type is used by the fuzzer to communicate
// the results of fuzzing back to the fuzzer, particulary to
// instruct the fuzzer that the `Input` case was unusable
// (for various reasons).
fuzz_target!(|input: Input| -> Corpus {
    // Each token needs to construct its own `Config` by passing
    // to `contract` a type that implements `ContractTokenOps`.
    let config = Config::contract(TokenOps);
    // Run the fuzzer.
    fuzz_token(config, input)
});

// Implements `ContractTokenOps`
struct TokenOps;

// Implements `TokenAdminClient`
struct AdminClient<'a> {
    client: CometPoolContractClient<'a>,
}

impl ContractTokenOps for TokenOps {
    /// Register the contract with the environment and perform
    /// contract-specific one-time initialization.
    ///
    /// This function will be called once.
    fn register_contract_init(&self, env: &Env, admin: &Address) -> Address {
        let token_contract_id = env.register_contract(None, CometPoolContract);

        let admin_client = CometPoolContractClient::new(env, &token_contract_id);

        let factory_address = admin.clone();
        let controller_address = admin.clone();
        
        let r = admin_client.try_init(
            &factory_address,
            &controller_address,
        );
        assert!(r.is_ok());

        // bind tokens
        let token_client_1 = create_and_init_token_contract(env, admin, "TOKENONE", "TOKENONE");
        let token_client_2 = create_and_init_token_contract(env, admin, "TOKENTWO", "TOKENTWO");

        env.mock_all_auths();
        token_client_1.mint(admin, &i128::MAX);
        token_client_2.mint(admin, &i128::MAX);

        // todo: const numbers
        admin_client.bind(&token_client_1.address, &to_stroop(40_000), &to_stroop(12), admin);
        admin_client.bind(&token_client_2.address, &to_stroop(50_000), &to_stroop(15), admin);

        let controller = admin.clone();
        admin_client.set_swap_fee(&3_000, &controller);
        admin_client.finalize();

        token_contract_id
    }

    /// Register the contract with the environment.
    ///
    /// This will be called on all subsequent transactions
    /// after the first, i.e. every time time is advanced
    /// and the `Env` is recreated.
    fn reregister_contract(&self, env: &Env, token_contract_id: &Address) {
        env.register_contract(Some(token_contract_id), CometPoolContract);
    }

    /// Create an admin client.
    fn new_admin_client<'a>(
        &self,
        env: &Env,
        token_contract_id: &Address,
    ) -> Box<dyn TokenAdminClient<'a> + 'a> {
        Box::new(AdminClient {
            client: CometPoolContractClient::new(&env, &token_contract_id),
        })
    }
}

impl<'a> TokenAdminClient<'a> for AdminClient<'a> {
    fn try_mint(
        &self,
        to: &Address,
        amount: &i128,
    ) -> Result<Result<(), <() as TryFromVal<Env, Val>>::Error>, Result<Error, InvokeError>> {
        self.client.env.mock_all_auths();
        self.client.env.budget().reset_unlimited();

        // todo: the number 100 is a random guess for minimal amount allowed
        if *amount <= 100{
            return Ok(Err(ConversionError::from(XdrError::Invalid)));
        }
        println!("**** try_mint. amount: {amount}");

        let pool_supply = self.client.get_total_supply();
        let new_pool_supply = pool_supply.checked_add(*amount).unwrap();
        let pool_ratio = new_pool_supply.fixed_div_floor(pool_supply, BONE).unwrap();

        if pool_ratio < MIN_CPOW_BASE || pool_ratio > MAX_CPOW_BASE {
            return Ok(Err(ConversionError::from(XdrError::Invalid)));
        }

        let pool_tokens = self.client.get_tokens();
        assert_eq!(pool_tokens.len(), 2);

        let token_address_1 = pool_tokens.get(0).unwrap_optimized();
        let token_address_2 = pool_tokens.get(1).unwrap_optimized();
        
        let token_client_1 = example_token::TokenClient::new(&self.client.env, &token_address_1);
        let token_client_2 = example_token::TokenClient::new(&self.client.env, &token_address_2);
        
        let r = panic::catch_unwind(AssertUnwindSafe(|| {
            let need_amount_in_1 = self.client.dep_lp_tokn_amt_out_get_tokn_in(&token_address_1, amount, &i128::MAX, to);
            let need_amount_in_2 = self.client.dep_lp_tokn_amt_out_get_tokn_in(&token_address_2, amount, &i128::MAX, to);

            println!("- need_amount_in_1: {need_amount_in_1}");
            println!("- need_amount_in_2: {need_amount_in_2}");

            token_client_1.mint(to, &need_amount_in_1);
            token_client_2.mint(to, &need_amount_in_2);

            let max_amounts_in = soroban_sdk::vec![&self.client.env, need_amount_in_1, need_amount_in_2];
            println!("before join_pool. max_amounts_in: {max_amounts_in:#?}");

            self.client.join_pool(amount, &max_amounts_in, to);
        }));
        assert!(r.is_err());

        println!("**** catch_unwind r: {r:#?}");
        
        Ok(Ok(()))
    }
}

fn create_and_init_token_contract<'a>(
    env: &'a Env,
    admin: &'a Address,
    name: &'a str,
    symbol: &'a str,
) -> example_token::TokenClient<'a> {
    let token_contract_id = env.register_contract(None, example_token::contract::Token);

    let client = example_token::TokenClient::new(&env, &token_contract_id);

    client.initialize(
        admin,
        &7,
        &String::from_str(&env, name),
        &String::from_str(&env, symbol),
    );

    client
}

fn to_stroop<T: Into<f64>>(a: T) -> i128 {
    (a.into() * 1e7) as i128
}
